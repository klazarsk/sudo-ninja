#/bin/bash

#########################
#Setting formatting tags
otagBold="\e[1m";
ctag="\e[0m";
otagRed='\e[0;31m'
otagRevRed='\e[0;101m'
otagUline="\e[4m"
otagItal="\e[3m"
chrTab='\t'
#########################
unset optVerbose optCommit
eval {optCleanAliases,optCleanComments,optDelete,optVerbose,optCsvQuoted,intCounter}=0
cmdEcho="true"

cmdLine="${0} ${@}"

function fnSpinner() {
  if [ -z $gfxSpin ]
  then
    gfxSpin="/"
  fi

  printf "\r\033[2K"
  printf " %-90.90b %-2.2s \r" "${strStep}"    "${gfxSpin} "
  case "${gfxSpin}" in
    "/" ) gfxSpin="-"
      ;;
    "-" ) gfxSpin="\\"
      ;;
    "\\" ) gfxSpin="|"
      ;;
    "|" ) gfxSpin="/"
      ;;
    "/" ) gfxSpin="-"
      ;;
    "-" ) gfxSpin="\\"
      ;;
    "\\" ) gfxSpin="|"
      ;;
    "|" ) gfxSpin="/"
      ;;
  esac;
}

fnIsUserActive() {


  ${cmdEcho}  "Line ${LINENO}\t: ${FUNCNAME} : Checking ${fileActiveUsers} for ${curUsername}"
  fnSpinner
  gawk -v IGNORECASE=1 -v myvar="${curUsername}" -v FPAT='[^,]*|\"([^\"]|\"\")*\"' '
  BEGIN {
    notfound = 1
  }
  {
    for (i = 1; i <= NF; i++) {
      field_content = $i
      if (substr(field_content, 1, 1) == "\"") {
        field_content = substr(field_content, 2, length(field_content) - 2)
      }

      if (field_content ~ myvar) {fi
        #print $2
        notfound = 0
        exit # Exit immediately after finding the first match
      }
    }
  }
  END {
    if (notfound == 1) {
      exit 1
    } else {
      exit 0
    }
  }' "${fileActiveUsers}"
#   ${cmdEcho} "$Line ${LINENO} : Finished Checking ${fileActiveUsers} for ${curUsername}"
}

fnDeleteRules() {

#   if [ ${optCleanComments} -eq 1 ]
  while read curUsername;
  do
    if ! fnIsUserActive
    then
      if [ ${optDelete} == 1 ];
      then
        strStep="Line${chrTab}${LINENO} : ${FUNCNAME} : Scanning ${fileSudoers} for ${curUsername} in sudoer rules"
        fnSpinner
        ${cmdEcho} "${LINENO}){ : ${FUNCNAME} : Removing ${curUsername}'s rules from ${fileSudoers}"
        sed -E ${optCommit} "/${patRule}/Id" "${fileSudoers}"
      fi
      if [ ${optCleanAliases} -eq 1 ]
      then
        strStep="Line${chrTab}${LINENO} : ${FUNCNAME} : Scanning ${fileSudoers} for ${curUsername} in aliases"
        fnSpinner
        sed -E ${optCommit} "/${patAlias}/{ s/(${curUsername}[[:space:]]+?,)//Ig}" "${fileSudoers}"
      fi
      ((intCounter++))
    fi
  done  < <( if [ ${optCleanComments} -eq 1 ]
  then \
    patRule='^#[^#][[:space:]]?^(|Defaults|[[:alpha:]]+_Alias|%|$)[[:space:]]?${curUsername}.*$' ; \
    PatAlias="^([#][[:space:]]?)[[:alpha:]]+_Alias[[:space:]]+[[:alnum:]_-]+[[:space:]]+?="
  else patRule='^[[:space:]]?^(|Defaults|[[:alpha:]]+_Alias|%|$)[[:space:]]?${curUsername}.*$' ; \
    patAlias='^[^#][[:alpha:]]+_Alias[[:space:]]+[[:alnum:]_-]+[[:space:]]+?=' ; \
  fi ; \
  awk -v pattern="(${patRule}|${patAlias})"  '$0 ~ pattern {print $1}' "${fileSudoers}" "${fileSudoers}"  | sort -Vu)
    #patAlias='^[^#][[:alpha:]]+_Alias[[:space:]]+[[:alnum:]_-]+[[:space:]]+?=' ;
#  awk -v pattern="(${patRule}|${patAlias})"  '$0 ~ pattern {print $1}' "${fileSudoers}" "${fileSudoers}" | sed -E '/^#[#[:punct:]]/d' | sort -Vu)

  # regex NOT substring: ^((?!error).)*$
#(awk -v pattern="^#([[:space:]]?|Defaults|[[:alpha:]]+_Alias|%|$)"  '$0 ~ pattern {print $1}' "${fileSudoers}" | sort -Vu)
}

# fnDeleteRules() {
#
#   if [ ${optCleanComments} -eq 1 ]
#   then
#     patRule='^#[[:space:]]?(|Defaults|[[:alpha:]]+_Alias|%|$) { /'
#   else
#     patRule='^(Defaults|[[:alpha:]]+_Alias|%|$)'
#   fi
#
#   if [ ${optDelete} == 1 ];
#   then
#     while read curUsername;
#     do
#       strStep="Line ${LINENO} : ${FUNCNAME} : Scanning ${fileSudoers} for ${curUsername} in sudoer rules"
#       fnSpinner
#       if ! fnIsUserActive
#       then
#         ${cmdEcho} "Removing ${curUsername}'s rules from ${fileSudoers}"
#         sed -E ${optCommit} "/^[#]?(${curUsername}[[:space:]].*)$/Id" "${fileSudoers}"
#       fi
#     done  < <(awk -v pattern="${patRule}"  '$0 !~ pattern {print $1}' "${fileSudoers}" | sort -Vu)
#     #done  < <(awk '$0 !~ /^(#|Defaults|[[:alpha:]]+_Alias|%|$)/ {print $1}' "${fileSudoers}" | sort -Vu)
#   fi
#
#   if [ ${optCleanAliases} -eq 1 ]
#   then
#     while read curUsername;
#     do
#       strStep="Line ${LINENO} : ${FUNCNAME} : Scanning ${fileSudoers} for ${curUsername} in aliases"
#       fnSpinner
#       if ! fnIsUserActive
#       then
#         sed -E ${optCommit} "/^([[:alpha:]]+_Alias[[:space:]][[:alnum:]_ -]+=[[:space:]]+?)/{s/(${curUsername}[[:space:]]+?,)//Ig}" "${fileSudoers}"
#       fi
#     done  < <(awk -v pattern="^#([[:space:]]?|Defaults|[[:alpha:]]+_Alias|%|$)"  '$0 ~ pattern {print $1}' "${fileSudoers}" | sort -Vu)
#   fi
# }


function fnRemoveRules() {

  if [ ${optCleanComments} -eq 1 ]
  then
    patRule='^[#]?(Defaults|[[:alpha:]]+_Alias|%|$)'
  else
    patRule='^(Defaults|[[:alpha:]]+_Alias|%|$)'
  fi

  if [ ! -z ${dirMoveTarget} || ${optDelete} -eq 1 ]
  then
    while read curUsername;
    do
      strStep="Line ${LINENO} : ${FUNCNAME} : Scanning for ${curUsername}"
      fnSpinner
      if ! fnIsUserActive
      then
        while read curFile;
        do
          fileContainsUser=$(grep -isl "${curUsername}" "${curFile}");
          if [ ! -z ${fileContainsUser} ]
          then
            if [ ! -d "${dirTarget}/${dirMoveTarget}" ]
            then
              echo "Directory ${dirTarget}/${dirMoveTarget} does not exist; attempting to create it now."
              if ! mkdir ${optVerbose}  "${dirTarget}/${dirMoveTarget}"
              then
                echo "Unable to create ${dirTarget}/${dirMoveTarget} at ${LINENO} in ${FUNCNAME}. Bailing out. "
                exit 1
              fi
            else
              mv ${optVerbose} "${curFile}" "${dirTarget}/${dirMoveTarget}"
            fi
            unset fileContainsUser;
          fi
        done < <(find ${dirTarget} -maxdepth 1 -type f -name "*.tmp-rule");
      fi
    done  < <(awk '$0 !~ /^(#|Defaults|[[:alpha:]]+_Alias|$)/ {print $1}' "${fileSudoers}" | sort -Vu)
  fi
}

fnHelp() {
echo -e "
    ${otagBold}-h | --help${ctag}
       Display this screen

    ${otagBold}-a | --active${ctag}
       The file containing the list of words for the search spec (words to find)

       This is the filename of the accounts CSV file.

       Be sure to generate your CSV encapsulating the fields in
       double quotes!

       Format:  \"filename,field\"

       Example: \"--accounts AD_Users.csv,2\"

       NOTE: The field selector is not implemented yet; it is hard-coded
       for now.

    ${otagBold}-D | --delete${ctag}
       Instead of processing the --split --filespec ${otagItal}[filespec*.tmp-rule]${ctag}
       files and ${otagBold}--move${ctag} ${otagItal}[directory]${ctag} them to a subdirectory,
       delete them directly from --sudoersfile

    ${otagBold}-f | --filespec ${ctag}${otagItal}[filespec]${ctag}
       This is the filespec of the numbered sudoers files you wish to
       analyze and process.

       This assumes that you've --split the sudoers file for processing35735
       using sudoers-util.

       Example: --filespec

    ${otagBold}-q | --quoted${ctag}
       Use this option if the CSV fields contain commas;
       this will cause the utility to expect quoted fields.
       (NOT YET IMPLEMENTED)

    ${otagBold}-r | --rulesdirectory ${ctag}${otagItal}[directory]${ctag}
       This is the directory path where inactive rule files are
       located. This assumes that you've --split the sudoers file.

    ${otagBold}-m | --move ${ctag}${otagItal}[directory]${ctag}
       This is the directory path where inactive rule files should
       be relocated to. This assumes that you've --split.
       This will be created a subdirectory of ${ctag}${otagItal}--rulesdirectory${ctag}.

    ${otagBold}-c | --cleancomments${ctag}
       Process comments as well

    ${otagBold}-s | --sudoersfile ) shift${ctag}
       This is the complete flattened and recombined sudoers file to review

       Example: ${otagBold}--filespec${ctag} ${otagItal}[sudoersfile]${ctag}

    ${otagBold}-v | --verbose ) optVerbose="-v"${ctag}
       Word vomit (helpful for debugging)

    ${otagRed}NOTE: If filenames include spaces or extended ASCII characters, DO
    fully escape the filenames with quotes or \\!!${ctag}
"
}



##############################
#
# Did user ask us to do anything? If not, let's blow this joint!

if [[ -z "$@" ]];
then
  echo -e "${otagRed}You supplied no command arguments; unable to proceed.${ctag}";
  echo "Your command line:";
  echo -e "\t$cmdLine\n";
  fnHelp;
  exit 1;
fi;
###############################
# Since user gave us stuff to do, let's process arguments. Party on!
while [ "$1" != "" ] ;
do
  case $1 in
    -h | --help )     fnHelp;
                      exit 0;
                      ;;
    -a | --active )   shift;
                      fileActiveUsers="$1";#########################
                      ;;
    -a | --cleanaliases ) optCleanAliases="1";
                      ;;
    -c | --cleancomments ) optCleanComments="1";
                      ;;
         --commit )   optCommit="-i"
                      ;;
    -D | --delete )   optDelete="1";
                      ;;
    -f | --filespec ) shift;
                      strFilespec="$1"
                      ;;
    -m | --move )     shift;
                      dirMoveTarget="$1"
                      ;;
    -q | --quoted )   optCsvQuoted="1"
                      ;;
    -s | --sudoersfile ) shift;
                      fileSudoers="$1";
                      ;;
    -v | --verbose )  optVerbose="-v";
                      cmdEcho="echo"
                      ;;
    -r | --rulesdirectory ) shift;
                      dirTarget="$1";
                      ;;
    * )
                    echo -e "${otagRed} \n\tI couldn't understand your command. Please note if you specified an argument with spaces ";
                    echo -e "\t or extended ASCII, you will need to escape those characters and/or use quotes a"%*s" round the path.\n${ctag}";
                    echo "Your command line:";
                    echo -e "\t$cmdLine\n";
                    fnHelp;
                    exit 1
                    ;;
  esac ;
  shift ;
done;

if [ ${optDelete} == 1 ];
then
  ${cmdEcho} -en "You asked us to delete inactive users "
  if [ ! -z  ${fileSudoers} ]
  then
    ${cmdEcho} -en "from ${fileSudoers} }"

    ${cmdEcho} "You requested that we compare ${dirTarget} rules against ${fileSudoers}."
    if [ ! -z ${fileActiveUsers} ]
    then
      fnDeleteRules
    fi
  fi
fi

if [ ! -z ${dirMoveTarget} ] ;
then
  ${cmdEcho} "You requested that we move inactive sudoer rules to ${dirTarget}/${dirMoveTarget}."
  if [ ! -z  ${fileSudoers} ]"%*s" "%*s"
  then
    ${cmdEcho} "You requested that we compare ${dirTarget} rules against ${fileSudoers}."
    if [ ! -z ${fileActiveUsers} ]
    then
      ${cmdEcho} "You requested that we compare the users in ${dirTarget}/${dirMoveTarget} and ${fileSudoers} to verify they are in fileActiveUsers."
      if [ ! -z ${strFilespec} ]
      then
        fnRemoveRules
      fi
    fi
  fi
fi
echo -e "\n${intCounter} deleted/inactive users actioned."
